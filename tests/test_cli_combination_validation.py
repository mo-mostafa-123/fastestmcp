#!/usr/bin/env python3
"""
Test CLI combination validation and performance limits
Tests for large component combinations, realistic limits, and performance boundaries
"""

import pytest
import subprocess
import sys
import tempfile
import time
from pathlib import Path
import psutil
import os


class TestCLICombinationValidation:
    """Test CLI with various component combinations and performance limits"""

    def test_realistic_limits_120_tools(self):
        """Test the realistic limit of 120 tools as mentioned by user"""
        with tempfile.TemporaryDirectory() as temp_dir:
            start_time = time.time()

            result = subprocess.run(
                [sys.executable, "-m", "fastestmcp.cli", "new", "--name", "realistic_120", "--tools", "120", "--output", temp_dir],
                capture_output=True,
                text=True,
                cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
            )

            end_time = time.time()
            duration = end_time - start_time

            # Should succeed within reasonable time
            assert result.returncode == 0
            assert duration < 30  # Should complete within 30 seconds

            # File should be generated
            expected_file = Path(temp_dir) / "realistic_120.py"
            assert expected_file.exists()

            # Check file size is reasonable
            file_size = expected_file.stat().st_size
            assert file_size > 1000  # Should be substantial
            assert file_size < 10_000_000  # Shouldn't be excessively large

    def test_large_component_combinations(self):
        """Test various large component combinations"""
        test_cases = [
            # (tools, resources, prompts, description)
            (50, 30, 20, "balanced_medium"),
            (100, 50, 25, "balanced_large"),
            (120, 60, 30, "realistic_max"),
            (200, 100, 50, "stress_test"),
            (0, 120, 60, "resources_focused"),
            (120, 0, 0, "tools_only"),
            (0, 0, 120, "prompts_only"),
        ]

        for tools, resources, prompts, description in test_cases:
            with tempfile.TemporaryDirectory() as temp_dir:
                start_time = time.time()

                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"combo_{description}",
                     "--tools", str(tools),
                     "--resources", str(resources),
                     "--prompts", str(prompts),
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                end_time = time.time()
                duration = end_time - start_time

                # Should succeed
                assert result.returncode == 0, f"Failed for {description}: {result.stderr}"

                # Should complete within reasonable time (scale with component count)
                max_duration = max(10, (tools + resources + prompts) / 10)  # 10 seconds base + 0.1s per component
                assert duration < max_duration, f"Took too long for {description}: {duration}s"

                # File should be generated
                expected_file = Path(temp_dir) / f"combo_{description}.py"
                assert expected_file.exists(), f"File not created for {description}"

                # Check file has expected content
                content = expected_file.read_text()
                assert "Generated by FastestMCP CLI" in content

                # Check component counts in content
                if tools > 0:
                    assert f"Tools: {tools}" in content or f"tools={tools}" in content
                if resources > 0:
                    assert f"Resources: {resources}" in content or f"resources={resources}" in content
                if prompts > 0:
                    assert f"Prompts: {prompts}" in content or f"prompts={prompts}" in content

    def test_structured_large_combinations(self):
        """Test large combinations with structured layout"""
        with tempfile.TemporaryDirectory() as temp_dir:
            start_time = time.time()

            result = subprocess.run(
                [sys.executable, "-m", "fastestmcp.cli", "new",
                 "--name", "structured_large",
                 "--tools", "80",
                 "--resources", "40",
                 "--prompts", "20",
                 "--structure", "structured",
                 "--output", temp_dir],
                capture_output=True,
                text=True,
                cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
            )

            end_time = time.time()
            duration = end_time - start_time

            # Should succeed
            assert result.returncode == 0
            assert duration < 45  # Structured generation can take longer

            # Directory should be created
            expected_dir = Path(temp_dir) / "structured_large"
            assert expected_dir.exists()
            assert expected_dir.is_dir()

            # Should have main files
            assert (expected_dir / "src" / "server.py").exists()
            assert (expected_dir / "src" / "__init__.py").exists()
            assert (expected_dir / "pyproject.toml").exists()

            # Should have src/components directory with components
            components_dir = expected_dir / "src" / "components"
            assert components_dir.exists()
            assert (components_dir / "tools.py").exists()
            assert (components_dir / "resources.py").exists()
            assert (components_dir / "prompts.py").exists()

    def test_memory_usage_large_generation(self):
        """Test memory usage during large component generation"""
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB

        with tempfile.TemporaryDirectory() as temp_dir:
            result = subprocess.run(
                [sys.executable, "-m", "fastestmcp.cli", "new",
                 "--name", "memory_test",
                 "--tools", "150",
                 "--resources", "75",
                 "--prompts", "50",
                 "--output", temp_dir],
                capture_output=True,
                text=True,
                cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
            )

            # Should succeed
            assert result.returncode == 0

            # Check memory usage didn't explode
            final_memory = process.memory_info().rss / 1024 / 1024  # MB
            memory_increase = final_memory - initial_memory

            # Memory increase should be reasonable (less than 500MB)
            assert memory_increase < 500, f"Memory usage increased by {memory_increase}MB"

    def test_performance_scaling(self):
        """Test how performance scales with component count"""
        component_counts = [10, 25, 50, 75, 100]
        times = []

        for count in component_counts:
            with tempfile.TemporaryDirectory() as temp_dir:
                start_time = time.time()

                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"scaling_{count}",
                     "--tools", str(count),
                     "--resources", str(count // 2),
                     "--prompts", str(count // 4),
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                end_time = time.time()
                duration = end_time - start_time

                assert result.returncode == 0
                times.append(duration)

        # Check that performance scales reasonably (not exponentially)
        # Each doubling shouldn't take more than 3x time
        for i in range(1, len(times)):
            ratio = times[i] / times[i-1] if times[i-1] > 0 else 0
            assert ratio < 4, f"Performance scaling issue at count {component_counts[i]}: {ratio}x slower"

    def test_file_size_scaling(self):
        """Test how file size scales with component count"""
        component_counts = [10, 25, 50, 75, 100]
        file_sizes = []

        for count in component_counts:
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"size_{count}",
                     "--tools", str(count),
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                assert result.returncode == 0

                expected_file = Path(temp_dir) / f"size_{count}.py"
                assert expected_file.exists()

                size = expected_file.stat().st_size
                file_sizes.append(size)

        # File size should scale roughly linearly with component count
        # Check that size per component is reasonable
        for i in range(1, len(file_sizes)):
            size_per_component = file_sizes[i] / component_counts[i]
            assert size_per_component > 10, f"File size too small per component: {size_per_component} bytes"
            assert size_per_component < 10000, f"File size too large per component: {size_per_component} bytes"

    def test_zero_components_edge_cases(self):
        """Test edge cases with zero components"""
        test_cases = [
            (0, 1, 1, "zero_tools"),
            (1, 0, 1, "zero_resources"),
            (1, 1, 0, "zero_prompts"),
            (0, 0, 0, "all_zero"),
        ]

        for tools, resources, prompts, description in test_cases:
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"zero_{description}",
                     "--tools", str(tools),
                     "--resources", str(resources),
                     "--prompts", str(prompts),
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                # Should succeed even with zero components
                assert result.returncode == 0, f"Failed for {description}: {result.stderr}"

                # File should be generated
                expected_file = Path(temp_dir) / f"zero_{description}.py"
                assert expected_file.exists()

    def test_extreme_combinations(self):
        """Test extreme combinations that push boundaries"""
        # Test with very high numbers
        extreme_cases = [
            (500, 0, 0, "extreme_tools"),
            (0, 500, 0, "extreme_resources"),
            (0, 0, 500, "extreme_prompts"),
            (200, 200, 200, "extreme_all"),
        ]

        for tools, resources, prompts, description in extreme_cases:
            with tempfile.TemporaryDirectory() as temp_dir:
                start_time = time.time()

                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"extreme_{description}",
                     "--tools", str(tools),
                     "--resources", str(resources),
                     "--prompts", str(prompts),
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src",
                    timeout=120  # 2 minute timeout for extreme cases
                )

                end_time = time.time()
                duration = end_time - start_time

                # Should either succeed or fail gracefully
                if result.returncode == 0:
                    # If it succeeds, check it completed in reasonable time
                    assert duration < 60, f"Extreme case took too long: {duration}s for {description}"

                    # File should be generated
                    expected_file = Path(temp_dir) / f"extreme_{description}.py"
                    assert expected_file.exists()

                    # File shouldn't be too large (reasonable limit: 50MB)
                    file_size = expected_file.stat().st_size
                    assert file_size < 50_000_000, f"File too large: {file_size} bytes for {description}"
                else:
                    # If it fails, it should be due to reasonable limits, not crashes
                    assert "MemoryError" not in result.stderr
                    assert "RecursionError" not in result.stderr

    def test_transport_combinations(self):
        """Test component combinations with different transports"""
        transports = ['stdio', 'http', 'sse']

        for transport in transports:
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"transport_{transport}",
                     "--tools", "30",
                     "--resources", "15",
                     "--prompts", "10",
                     "--transport", transport,
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                # Should succeed
                assert result.returncode == 0, f"Failed for transport {transport}: {result.stderr}"

                # File should be generated
                expected_file = Path(temp_dir) / f"transport_{transport}.py"
                assert expected_file.exists()

                # Check transport-specific content
                content = expected_file.read_text()
                if transport == 'http':
                    assert 'http' in content.lower() or 'httpx' in content.lower()
                elif transport == 'sse':
                    assert 'sse' in content.lower()

    def test_server_type_combinations(self):
        """Test component combinations with different server types"""
        server_types = ['fastmcp', 'mcp']

        for server_type in server_types:
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"type_{server_type}",
                     "--tools", "25",
                     "--resources", "12",
                     "--prompts", "8",
                     "--type", server_type,
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                # Should succeed
                assert result.returncode == 0, f"Failed for server type {server_type}: {result.stderr}"

                # File should be generated
                expected_file = Path(temp_dir) / f"type_{server_type}.py"
                assert expected_file.exists()

                # Check server-type-specific content
                content = expected_file.read_text()
                if server_type == 'fastmcp':
                    assert 'fastmcp' in content.lower() or 'FastMCP' in content
                elif server_type == 'mcp':
                    assert 'mcp' in content.lower()

    def test_structure_combinations(self):
        """Test component combinations with different structures"""
        structures = ['mono', 'structured']

        for structure in structures:
            with tempfile.TemporaryDirectory() as temp_dir:
                result = subprocess.run(
                    [sys.executable, "-m", "fastestmcp.cli", "new",
                     "--name", f"structure_{structure}",
                     "--tools", "20",
                     "--resources", "10",
                     "--prompts", "5",
                     "--structure", structure,
                     "--output", temp_dir],
                    capture_output=True,
                    text=True,
                    cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
                )

                # Should succeed
                assert result.returncode == 0, f"Failed for structure {structure}: {result.stderr}"

                if structure == 'mono':
                    # Should generate single file
                    expected_file = Path(temp_dir) / f"structure_{structure}.py"
                    assert expected_file.exists()
                else:
                    # Should generate directory structure with src/server.py
                    expected_dir = Path(temp_dir) / f"structure_{structure}"
                    assert expected_dir.exists()
                    assert expected_dir.is_dir()
                    assert (expected_dir / "src" / "server.py").exists()

    def test_combined_limits_realistic_scenario(self):
        """Test a realistic scenario with combined limits"""
        # This represents a comprehensive MCP server
        with tempfile.TemporaryDirectory() as temp_dir:
            start_time = time.time()

            result = subprocess.run(
                [sys.executable, "-m", "fastestmcp.cli", "new",
                 "--name", "comprehensive_server",
                 "--tools", "120",      # Realistic tool limit
                 "--resources", "60",   # Supporting resources
                 "--prompts", "30",     # Reasonable prompts
                 "--transport", "http", # Production transport
                 "--structure", "structured", # Production structure
                 "--type", "fastmcp",   # Modern server type
                 "--output", temp_dir],
                capture_output=True,
                text=True,
                cwd="/Users/jwink/Documents/github/fastmcp-templates/src"
            )

            end_time = time.time()
            duration = end_time - start_time

            # Should succeed
            assert result.returncode == 0

            # Should complete within reasonable time for production use
            assert duration < 60, f"Production scenario took too long: {duration}s"

            # Should generate proper directory structure
            expected_dir = Path(temp_dir) / "comprehensive_server"
            assert expected_dir.exists()

            # Should have all necessary files
            assert (expected_dir / "src" / "server.py").exists()
            assert (expected_dir / "pyproject.toml").exists()
            assert (expected_dir / "src" / "components").exists()
            assert (expected_dir / "src" / "components" / "tools.py").exists()
            assert (expected_dir / "src" / "components" / "resources.py").exists()
            assert (expected_dir / "src" / "components" / "prompts.py").exists()

            # Check that generated files are functional
            server_file = expected_dir / "src" / "server.py"
            content = server_file.read_text()

            # Should contain proper imports and structure
            assert "from fastestmcp" in content or "from mcp" in content
            assert "FastMCP" in content or "FastMCP" in content

            # Check total content across all generated files
            total_content = ""
            for file_path in expected_dir.rglob("*.py"):
                if file_path.is_file():
                    total_content += file_path.read_text()

            # Should have substantial content for the component counts
            # With 120 tools + 60 resources + 30 prompts, should be substantial but efficient (new component system)
            assert len(total_content) > 5000, f"Total generated content too small: {len(total_content)} chars"

            # Should have the right number of tool/resource registrations
            # New component system uses one register_component call per component type with count parameter
            assert 'count=120' in total_content, "Should have 120 tools registered"
            assert 'count=60' in total_content, "Should have 60 resources registered"
            assert 'count=30' in total_content, "Should have 30 prompts registered"

            # Should have exactly 3 register_component function calls (tools, resources, prompts)
            # Count only the actual function calls, not the imports
            function_calls = total_content.count("result = register_component(")
            assert function_calls == 3, f"Expected 3 register_component function calls, found {function_calls}"