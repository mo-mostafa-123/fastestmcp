# Context Management Approaches: Config-Driven vs. Self-Documenting Chain

## 1. Config-Driven (YAML Template)

- **Structure:**
  - Uses a YAML file to define the superset, order, and grouping of context fields.
  - Code reads the YAML and outputs only fields present/populated in the current context.
- **Example YAML:**

```yaml
# context_structure.yaml
# Fields below this line were generated by the system. Do not edit these lines directly.
# --- GENERATED START ---
- user_id
- session_id
- input
- history
- metadata:
    - source
    - timestamp
    - tags
# --- GENERATED END ---
# You may reorder, indent, or add fields below. Add your custom fields or overrides after this line.
# Example:
# - custom_field
# - metadata:
#     - extra_info

### uncategorized--chronological ###
- new_field
```

- **Example Code:**

```python
import yaml
class ContextManager:
    def __init__(self, structure_path):
        with open(structure_path) as f:
            self.structure = yaml.safe_load(f)
    def _assemble(self, structure, context):
        result = {}
        for item in structure:
            if isinstance(item, str):
                if item in context and context[item] is not None:
                    result[item] = context[item]
            elif isinstance(item, dict):
                for k, v in item.items():
                    if k in context and isinstance(context[k], dict):
                        nested = self._assemble(v, context[k])
                        if nested:
                            result[k] = nested
        return result
    def format_message(self, context):
        return self._assemble(self.structure, context)
```

- **Pros:**
  - Explicit, easy to reorder/group, non-devs can edit YAML.
- **Cons:**
  - Requires manual updates, config/code drift risk, more boilerplate.

---

## 2. Self-Documenting Chain (modulink-py style)

- **Structure:**
  - Context/data flow is explicit in the code as a chain of functions or modules.
  - Each function documents its input/output, and only includes fields that are present/populated.
- **Example Code:**

```python
def build_context(user, session, input, history=None, metadata=None, **kwargs):
    """
    Builds the context for the model.
    Args:
        user: User info
        session: Session info
        input: User input
        history: Conversation history (optional)
        metadata: Additional metadata (optional)
    Returns:
        dict: Context for the model
    """
    ctx = {"user_id": user.id, "session_id": session.id, "input": input}
    if history: ctx["history"] = history
    if metadata: ctx["metadata"] = metadata
    # ...add more as needed
    return ctx
```

- **Pros:**
  - Self-documenting, always up to date, less config, easier for devs to maintain.
- **Cons:**
  - Order/grouping is controlled in code, not as easily changed by non-devs.

---

## Summary Table

| Approach         | Order/Grouping | Editable by | Self-Documenting | Maintenance |
|------------------|---------------|-------------|------------------|-------------|
| Config-Driven    | YAML          | Anyone      | No               | More manual |
| Self-Documenting | Code          | Devs        | Yes              | Less manual |

---

**Choose config-driven if you want non-devs to control structure/order.**

**Choose self-documenting chain if you want maintainability, clarity, and always-up-to-date context.**
