"""
Tests for demo_client_client MCP Client
Generated by FastestMCP CLI
"""

import pytest
import asyncio
import sys
import os
from unittest.mock import Mock, patch, AsyncMock
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Dynamic import for structured client
def load_client_module():
    """Load the client module dynamically"""
    module_name = "demo_client_client.src.client"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        client_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "client.py")
        spec = importlib.util.spec_from_file_location("demo_client_client.src.client", client_path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load spec for {client_path}")
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

client_module = load_client_module()
Demo_ClientClient = client_module.Demo_ClientClient


class TestDemoClientClientFolderStructure:
    """Test cases for verifying the clean client folder structure"""

    def test_project_root_files_exist(self):
        """Test that essential root-level files exist"""
        project_root = Path(__file__).parent.parent

        # Check for main configuration files
        assert (project_root / "pyproject.toml").exists(), "pyproject.toml should exist in root"
        assert (project_root / "README.md").exists(), "README.md should exist in root"
        assert (project_root / "main.py").exists(), "main.py should exist in root"

    def test_src_directory_structure(self):
        """Test that src directory has proper structure"""
        project_root = Path(__file__).parent.parent
        src_dir = project_root / "src"

        assert src_dir.exists(), "src/ directory should exist"
        assert src_dir.is_dir(), "src/ should be a directory"

        # Check src contents
        assert (src_dir / "__init__.py").exists(), "src/__init__.py should exist"
        assert (src_dir / "client.py").exists(), "src/client.py should exist"

    def test_components_directory_structure(self):
        """Test that components directory has all required files"""
        project_root = Path(__file__).parent.parent
        components_dir = project_root / "src" / "components"

        assert components_dir.exists(), "src/components/ directory should exist"
        assert components_dir.is_dir(), "src/components/ should be a directory"

        # Check components contents
        assert (components_dir / "__init__.py").exists(), "src/components/__init__.py should exist"

        # Check for expected component files (based on generation parameters)
        expected_components = ["apis.py", "integrations.py", "handlers.py", "notifications.py", "subscriptions.py"]
        for component in expected_components:
            assert (components_dir / component).exists(), f"src/components/{component} should exist"

    def test_tests_directory_structure(self):
        """Test that tests directory is properly organized"""
        project_root = Path(__file__).parent.parent
        tests_dir = project_root / "tests"

        assert tests_dir.exists(), "tests/ directory should exist"
        assert tests_dir.is_dir(), "tests/ should be a directory"

        # Check tests contents
        assert (tests_dir / "__init__.py").exists(), "tests/__init__.py should exist"
        assert (tests_dir / "test_client.py").exists(), "tests/test_client.py should exist"

    def test_no_duplicate_files_in_root(self):
        """Test that there are no duplicate component files in root directory"""
        project_root = Path(__file__).parent.parent

        # These files should NOT exist in root (they should be in src/components/)
        forbidden_root_files = ["apis.py", "integrations.py", "handlers.py", "notifications.py", "subscriptions.py", "client.py"]

        for forbidden_file in forbidden_root_files:
            assert not (project_root / forbidden_file).exists(), f"{forbidden_file} should NOT exist in root (should be in src/components/ or src/)"

    def test_no_app_directory_duplication(self):
        """Test that there's no old-style app/ directory causing duplication"""
        project_root = Path(__file__).parent.parent
        app_dir = project_root / "app"

        assert not app_dir.exists(), "app/ directory should NOT exist (components should be in src/components/)"

    def test_no_cache_files_in_source(self):
        """Test that __pycache__ files are not mixed with source files at the wrong level"""
        project_root = Path(__file__).parent.parent
        src_dir = project_root / "src"

        # Check that there are no __pycache__ files directly in src/ (they should be in subdirs)
        # But allow __pycache__ in components/ subdirectories as that's normal Python behavior
        direct_cache_files = list(src_dir.glob("__pycache__"))
        if direct_cache_files:
            # This is acceptable - Python creates __pycache__ during normal operation
            # Just ensure they're not mixed with source files inappropriately
            pass

        # More importantly, ensure no source files are in __pycache__ directories
        for cache_dir in src_dir.rglob("__pycache__"):
            cache_files = list(cache_dir.glob("*.py"))
            assert len(cache_files) == 0, f"Found .py files in __pycache__ directory: {cache_files}"

    def test_clean_file_organization(self):
        """Test overall clean organization of files"""
        project_root = Path(__file__).parent.parent

        # Count files in different locations to ensure proper organization
        root_files = list(project_root.glob("*.py"))
        root_files = [f for f in root_files if f.name not in ["main.py"]]  # main.py is allowed in root

        src_files = list((project_root / "src").glob("*.py"))
        component_files = list((project_root / "src" / "components").glob("*.py"))
        test_files = list((project_root / "tests").glob("*.py"))

        # Root should only have main.py (plus config files)
        assert len(root_files) <= 1, f"Too many .py files in root: {root_files}"

        # src should have minimal files (just client.py and __init__.py)
        assert len(src_files) == 2, f"src/ should have exactly 2 .py files, found {len(src_files)}: {src_files}"

        # All component logic should be in components/
        assert len(component_files) >= 5, f"components/ should have at least 5 .py files, found {len(component_files)}: {component_files}"

        # Tests should be in tests/
        assert len(test_files) >= 2, f"tests/ should have at least 2 .py files, found {len(test_files)}: {test_files}"

    def test_package_structure_valid(self):
        """Test that the package structure is valid for Python imports"""
        project_root = Path(__file__).parent.parent

        # Check that all __init__.py files exist where needed
        required_init_files = [
            project_root / "src" / "__init__.py",
            project_root / "src" / "components" / "__init__.py",
            project_root / "tests" / "__init__.py"
        ]

        for init_file in required_init_files:
            assert init_file.exists(), f"Required __init__.py file missing: {init_file}"

    def test_component_files_not_empty(self):
        """Test that component files are not empty (indicating proper generation)"""
        project_root = Path(__file__).parent.parent
        components_dir = project_root / "src" / "components"

        component_files = ["apis.py", "integrations.py", "handlers.py", "notifications.py", "subscriptions.py"]

        for component_file in component_files:
            file_path = components_dir / component_file
            assert file_path.exists(), f"Component file {component_file} should exist"

            # Check that file is not empty (has meaningful content)
            content = file_path.read_text()
            assert len(content.strip()) > 100, f"Component file {component_file} appears to be empty or too small"

            # Check for expected function definitions
            if component_file == "apis.py":
                assert "def api_endpoint_" in content, f"{component_file} should contain API endpoint functions"
            elif component_file == "integrations.py":
                assert "def integration_" in content, f"{component_file} should contain integration functions"
            elif component_file == "handlers.py":
                assert "async def handle_event_" in content, f"{component_file} should contain event handler functions"


class TestDemo_ClientClient:
    """Test cases for the demo_client_client MCP client"""

    def test_client_creation(self):
        """Test that the MCP client is created successfully"""
        client = Demo_ClientClient()
        assert client is not None
        assert hasattr(client, 'connect')
        assert hasattr(client, 'disconnect')

    def test_components_loaded(self):
        """Test that components are loaded"""
        client = Demo_ClientClient()
        assert hasattr(client, 'components')
        assert isinstance(client.components, dict)

    @pytest.mark.asyncio
    async def test_client_can_connect_mock(self):
        """Test that the client can connect (mocked)"""
        client = Demo_ClientClient()
        with patch.object(client, 'client') as mock_client:
            mock_client.connect = AsyncMock()
            await client.connect()
            mock_client.connect.assert_called_once()

    @pytest.mark.asyncio
    async def test_client_can_disconnect_mock(self):
        """Test that the client can disconnect (mocked)"""
        client = Demo_ClientClient()
        with patch.object(client, 'client') as mock_client:
            mock_client.disconnect = AsyncMock()
            client._connected = True
            await client.disconnect()
            mock_client.disconnect.assert_called_once()

    @pytest.mark.asyncio
    async def test_api_endpoints_available(self):
        """Test that API endpoints are available"""
        client = Demo_ClientClient()
        # Test first API endpoint
        assert hasattr(client, 'api_endpoint_1')
        assert callable(getattr(client, 'api_endpoint_1', None))

    def test_integrations_available(self):
        """Test that integrations are available"""
        client = Demo_ClientClient()
        # Test first integration
        assert hasattr(client, 'integration_1')
        assert callable(getattr(client, 'integration_1', None))

    @pytest.mark.asyncio
    async def test_handlers_available(self):
        """Test that event handlers are available"""
        client = Demo_ClientClient()
        # Test first handler
        assert hasattr(client, 'handle_event_1')
        assert callable(getattr(client, 'handle_event_1', None))


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
