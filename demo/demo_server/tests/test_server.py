"""
Tests for demo_server MCP Server
Generated by FastestMCP CLI
"""

import pytest
import sys
import os
from unittest.mock import Mock, patch, AsyncMock
from pathlib import Path

# Add the parent directory to sys.path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Dynamic import for structured project
def load_server_module():
    """Load the server module dynamically"""
    module_name = "demo_server.src.server"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        server_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "server.py")
        spec = importlib.util.spec_from_file_location("demo_server.src.server", server_path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load spec for {server_path}")
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

def load_tools_module():
    """Load the tools module dynamically"""
    module_name = "demo_server.src.components.tools"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        tools_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "components", "tools.py")
        spec = importlib.util.spec_from_file_location("demo_server.src.components.tools", tools_path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load spec for {tools_path}")
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

def load_resources_module():
    """Load the resources module dynamically"""
    module_name = "demo_server.src.components.resources"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        resources_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "components", "resources.py")
        spec = importlib.util.spec_from_file_location("demo_server.src.components.resources", resources_path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load spec for {resources_path}")
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

server_module = load_server_module()
tools_module = load_tools_module()
resources_module = load_resources_module()

app = server_module.app
tools = tools_module
resources = resources_module


class TestDemoServerFolderStructure:
    """Test cases for verifying the clean folder structure"""

    def test_project_root_files_exist(self):
        """Test that essential root-level files exist"""
        project_root = Path(__file__).parent.parent

        # Check for main configuration files
        assert (project_root / "pyproject.toml").exists(), "pyproject.toml should exist in root"
        assert (project_root / "README.md").exists(), "README.md should exist in root"
        assert (project_root / "main.py").exists(), "main.py should exist in root"

    def test_src_directory_structure(self):
        """Test that src directory has proper structure"""
        project_root = Path(__file__).parent.parent
        src_dir = project_root / "src"

        assert src_dir.exists(), "src/ directory should exist"
        assert src_dir.is_dir(), "src/ should be a directory"

        # Check src contents
        assert (src_dir / "__init__.py").exists(), "src/__init__.py should exist"
        assert (src_dir / "server.py").exists(), "src/server.py should exist"

    def test_components_directory_structure(self):
        """Test that components directory has all required files"""
        project_root = Path(__file__).parent.parent
        components_dir = project_root / "src" / "components"

        assert components_dir.exists(), "src/components/ directory should exist"
        assert components_dir.is_dir(), "src/components/ should be a directory"

        # Check components contents
        assert (components_dir / "__init__.py").exists(), "src/components/__init__.py should exist"

        # Check for expected component files (based on generation parameters)
        expected_components = ["tools.py", "resources.py", "prompts.py", "notifications.py", "subscriptions.py"]
        for component in expected_components:
            assert (components_dir / component).exists(), f"src/components/{component} should exist"

    def test_tests_directory_structure(self):
        """Test that tests directory is properly organized"""
        project_root = Path(__file__).parent.parent
        tests_dir = project_root / "tests"

        assert tests_dir.exists(), "tests/ directory should exist"
        assert tests_dir.is_dir(), "tests/ should be a directory"

        # Check tests contents
        assert (tests_dir / "__init__.py").exists(), "tests/__init__.py should exist"
        assert (tests_dir / "test_server.py").exists(), "tests/test_server.py should exist"

    def test_no_duplicate_files_in_root(self):
        """Test that there are no duplicate component files in root directory"""
        project_root = Path(__file__).parent.parent

        # These files should NOT exist in root (they should be in src/components/)
        forbidden_root_files = ["tools.py", "resources.py", "prompts.py", "notifications.py", "subscriptions.py"]

        for forbidden_file in forbidden_root_files:
            assert not (project_root / forbidden_file).exists(), f"{forbidden_file} should NOT exist in root (should be in src/components/)"

    def test_no_app_directory_duplication(self):
        """Test that there's no old-style app/ directory causing duplication"""
        project_root = Path(__file__).parent.parent
        app_dir = project_root / "app"

        assert not app_dir.exists(), "app/ directory should NOT exist (components should be in src/components/)"

    def test_no_cache_files_in_source(self):
        """Test that __pycache__ files are not mixed with source files at the wrong level"""
        project_root = Path(__file__).parent.parent
        src_dir = project_root / "src"

        # Check that there are no __pycache__ files directly in src/ (they should be in subdirs)
        # But allow __pycache__ in components/ subdirectories as that's normal Python behavior
        direct_cache_files = list(src_dir.glob("__pycache__"))
        if direct_cache_files:
            # This is acceptable - Python creates __pycache__ during normal operation
            # Just ensure they're not mixed with source files inappropriately
            pass

        # More importantly, ensure no source files are in __pycache__ directories
        for cache_dir in src_dir.rglob("__pycache__"):
            cache_files = list(cache_dir.glob("*.py"))
            assert len(cache_files) == 0, f"Found .py files in __pycache__ directory: {cache_files}"

    def test_clean_file_organization(self):
        """Test overall clean organization of files"""
        project_root = Path(__file__).parent.parent

        # Count files in different locations to ensure proper organization
        root_files = list(project_root.glob("*.py"))
        root_files = [f for f in root_files if f.name not in ["main.py"]]  # main.py is allowed in root

        src_files = list((project_root / "src").glob("*.py"))
        component_files = list((project_root / "src" / "components").glob("*.py"))
        test_files = list((project_root / "tests").glob("*.py"))

        # Root should only have main.py (plus config files)
        assert len(root_files) <= 1, f"Too many .py files in root: {root_files}"

        # src should have minimal files (just server.py and __init__.py)
        assert len(src_files) == 2, f"src/ should have exactly 2 .py files, found {len(src_files)}: {src_files}"

        # All component logic should be in components/
        assert len(component_files) >= 5, f"components/ should have at least 5 .py files, found {len(component_files)}: {component_files}"

        # Tests should be in tests/
        assert len(test_files) >= 2, f"tests/ should have at least 2 .py files, found {len(test_files)}: {test_files}"

    def test_package_structure_valid(self):
        """Test that the package structure is valid for Python imports"""
        project_root = Path(__file__).parent.parent

        # Check that all __init__.py files exist where needed
        required_init_files = [
            project_root / "src" / "__init__.py",
            project_root / "src" / "components" / "__init__.py",
            project_root / "tests" / "__init__.py"
        ]

        for init_file in required_init_files:
            assert init_file.exists(), f"Required __init__.py file missing: {init_file}"


class TestDemoserverServer:
    """Test cases for the demo_server MCP server"""

    def test_server_creation(self):
        """Test that the MCP server is created successfully"""
        assert app is not None
        assert hasattr(app, 'name')
        assert "demo_server" in app.name

    def test_tools_module_import(self):
        """Test that tools module can be imported"""
        assert tools is not None
        assert hasattr(tools, 'register_tools')

    def test_resources_module_import(self):
        """Test that resources module can be imported"""
        assert resources is not None
        assert hasattr(resources, 'register_resources')

    @pytest.mark.asyncio
    async def test_server_can_start(self):
        """Test that the server can be started (mocked)"""
        with patch.object(app, 'run_stdio_async', new_callable=AsyncMock) as mock_run:
            # We can't actually run the server in tests, but we can verify the method exists
            assert hasattr(app, 'run_stdio_async')
            assert callable(app.run_stdio_async)

    def test_tools_registration(self):
        """Test tools registration with mocked server"""
        mock_server = Mock()
        result = tools.register_tools(mock_server)
        assert result["success"] == True
        assert result["count"] == 3

    def test_resources_registration(self):
        """Test resources registration with mocked server"""
        mock_server = Mock()
        result = resources.register_resources(mock_server)
        assert result["success"] == True
        assert result["count"] == 2


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
    """Test cases for the demo_server MCP server"""

    def test_server_creation(self):
        """Test that the MCP server is created successfully"""
        assert app is not None
        assert hasattr(app, 'name')
        assert "demo_server" in app.name

    def test_tools_module_import(self):
        """Test that tools module can be imported"""
        assert tools is not None
        assert hasattr(tools, 'register_tools')

    def test_resources_module_import(self):
        """Test that resources module can be imported"""
        assert resources is not None
        assert hasattr(resources, 'register_resources')

    @pytest.mark.asyncio
    async def test_server_can_start(self):
        """Test that the server can be started (mocked)"""
        with patch.object(app, 'run_stdio_async', new_callable=AsyncMock) as mock_run:
            # We can't actually run the server in tests, but we can verify the method exists
            assert hasattr(app, 'run_stdio_async')
            assert callable(app.run_stdio_async)

    def test_tools_registration(self):
        """Test tools registration with mocked server"""
        mock_server = Mock()
        result = tools.register_tools(mock_server)
        assert result["success"] == True
        assert result["count"] == 3

    def test_resources_registration(self):
        """Test resources registration with mocked server"""
        mock_server = Mock()
        result = resources.register_resources(mock_server)
        assert result["success"] == True
        assert result["count"] == 2


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
